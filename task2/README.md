cd ...\task2  
cmake ../task2  
cd Debug  
.\matrix_mul_block.exe

2. Измерение времени работы программы для различных размеров блоков и предложение оптимального варианта
   Результаты тестирования:
   В процессе тестирования программы для различных значений BLOCK_SIZE были получены следующие результаты времени работы:

BLOCK_SIZE = 8: 0.086000 секунд
BLOCK_SIZE = 16: 0.107000 секунд
BLOCK_SIZE = 32: 0.082000 секунд
BLOCK_SIZE = 64: 0.086000 секунд
BLOCK_SIZE = 128: 0.096000 секунд
BLOCK_SIZE = 256: 0.101000 секунд
Анализ:
BLOCK_SIZE = 32 показал наименьшее время (0.082 секунд). Это значение блока оказалось наиболее оптимальным для вашего GPU, обеспечивая эффективное использование ресурсов.
BLOCK_SIZE = 8 также показал достаточно хорошее время (0.086 секунд), но блок размером 8 слишком мал для эффективного использования доступных потоков и памяти, что может объяснить его менее эффективное использование.
BLOCK_SIZE = 16 показал наихудшее время (0.107 секунд), что говорит о том, что этот размер блока может быть слишком мал для эффективного параллелизма, но не достаточно мал, чтобы избежать излишней работы с памятью.
BLOCK_SIZE = 64, 128 и 256 также показали более высокие времена (0.086, 0.096 и 0.101 секунд соответственно), что подтверждает, что более крупные блоки могут вести к увеличению времени выполнения из-за более сложной синхронизации потоков и больших затрат на доступ к памяти.
Оптимальный размер блока:
BLOCK_SIZE = 32 оказался наилучшим вариантом для вашего GPU. Это значение блока позволяет достичь хорошего баланса между количеством потоков и доступом к памяти, эффективно используя shared memory и минимизируя время доступа к глобальной памяти.
Причины повышения производительности с BLOCK_SIZE = 32:
Размер блока 32x32 оптимален для современных графических процессоров, так как позволяет эффективно использовать shared memory и минимизировать число обращений к глобальной памяти.
Блоки, которые слишком малы (например, 8x8), не используют все доступные потоки GPU и не дают максимальной производительности.
Очень большие блоки (например, 256x256) могут вызвать перерасход памяти, из-за чего потоки будут конкурировать за доступ к памяти, что также может замедлить выполнение.

---

Отчет по результатам работы

1. Цель работы:
   Целью лабораторной работы было использование блочного матричного умножения для повышения производительности при умножении матриц с использованием технологии CUDA.

Этапы работы: 2. Модификация программы:

Программа была изменена для реализации блочного матричного умножения. Матрицы A и B были разделены на блоки размером BLOCK_SIZE x BLOCK_SIZE для эффективной работы с shared memory. Это позволяет уменьшить количество обращений к глобальной памяти и ускорить выполнение программы. 3. Измерение времени работы программы для различных блоков:

Для разных значений BLOCK_SIZE (8, 16, 32, 64, 128, 256) были измерены времена выполнения программы.
Наилучшее время выполнения было получено при BLOCK_SIZE = 32. Это значение блока оптимально подходит для большинства современных GPU, обеспечивая хороший баланс между количеством потоков и доступом к памяти. 4. Объяснение повышения производительности при использовании BLOCK_SIZE = 32:

Размер блока 32x32 оптимален, так как он позволяет эффективно использовать shared memory и минимизировать время, необходимое для доступа к глобальной памяти.
Слишком малые блоки (например, 8x8) не используют все возможности GPU, а слишком большие блоки (например, 256x256) приводят к излишним затратам на синхронизацию потоков и доступ к памяти.
